---
layout: post
title: 알고리즘 스터디 3주차 - 정렬 2309번
date: 2021-10-07 19:12:00 +0900
author: leeeha
description: 정렬 알고리즘 2309번 문제풀이
categories: ["study"]
---

안녕하세요. GDSC 안드로이드 파트 멤버 이하은입니다! <br>
제가 이번 3주차에 맡은 문제는 2309번 입니다. 이름부터 호기심이 드는 문제인데, 어떤 문제인지 같이 보시죠! <br>

# 백준 정렬 2309번. 일곱 난쟁이

https://www.acmicpc.net/problem/2309 <br>

![image](https://user-images.githubusercontent.com/68090939/136366170-cc42222e-77d9-4625-b85e-fa2311a4d085.png)

![image](https://user-images.githubusercontent.com/68090939/136373061-1c6f9e23-3db2-4448-8178-74c3cd349dfd.png)

가짜 난쟁이 2명을 어떻게 찾을 수 있을까요? 중요한 단서는 진짜 난쟁이 7명의 키의 합이 100이라는 것입니다. 따라서 9명의 키를 모두 더한 값에서 100을 뺀 다음에, 그 차이를 만들어낸 가짜 난쟁이 2명을 찾으면 됩니다! 9명 중에 2명을 찾아야 하니까 총 $$9_C_2 = 36$$ 번 검사를 해야 합니다. 이것을 코드로 구현하려면 어떻게 해야 할까요? <br>

문제에 주어진 입력 예시는 다음과 같습니다. <br>

> 20
7
23
19
10
15  <- i=5
25  <- j=6
8
13

위의 숫자들을 다 더하면 140이 나오는데요, 여기서 100을 뺐을 때 40이라는 차이를 만들어낸 난쟁이 두 명을 찾으면 됩니다.<br>
아래 코드처럼 이중 반복문을 이용하면 되는데요, 이때 외부 루프는 합이 gap과 같아지는 두 원소를 찾을 때까지 반복되며, 내부 루프는 외부 루프의 현재 인덱스 바로 다음부터 배열 끝까지 탐색을 진행합니다.<br>

```cpp
bool found = false;
	int i = 0;
	while (!found) { // not found라면 반복
		for (int j = i + 1; j < 9; j++) {
			if (arr[i] + arr[j] == gap) {
				// 가짜 난쟁이의 키는 0으로 만들기
				arr[i] = 0, arr[j] = 0;
				found = true;
				break;
			}
		}
		i++;
	}
```

C++의 기본 배열은 원소 자체를 제거할 수 있는 방법이 없어서, 값을 0으로 만들고 출력에서는 이를 제외하는 방식으로 풀었습니다. 하지만, vector 컨테이너의 erase 함수를 사용하면 원소를 제거할 수 있습니다. 다만 주의할 점은 erase로 원소를 삭제하면 자동으로 한칸씩 원소들이 앞으로 당겨지기 때문에 i번째, j-1번째 원소를 삭제해줘야 합니다. 아래 코드를 보시죠! <br>
http://www.cplusplus.com/reference/vector/vector/erase/

# C++ 풀이

## 1. 기본 배열

```cpp
#include <iostream>
#include <algorithm> // std::sort
using namespace std;

int main()
{
	int arr[9]{}; // 0으로 초기화
	int sum = 0;

	// 난쟁이 9명의 키를 입력 받는다.
	for (int i = 0; i < 9; i++) {
		scanf("%d", &arr[i]);
		sum += arr[i];
	}

	int gap = sum - 100;

	bool found = false;
	int i = 0;
	while (!found) { // not found라면 반복
		for (int j = i + 1; j < 9; j++) {
			if (arr[i] + arr[j] == gap) {
				// 가짜 난쟁이의 키는 0으로 만들기
				arr[i] = 0, arr[j] = 0;
				found = true;
				break;
			}
		}
		i++;
	}

	// 오름차순 정렬
	std::sort(arr, arr + 9);

	// 0을 제외하고 7명의 난쟁이 키 출력
	for (int i = 2; i < 9; i++)
		printf("%d\n", arr[i]);

	return 0;
}
```

## 2. vector 컨테이너 사용

```cpp
#include <iostream>
#include <algorithm> // std::sort
#include <vector>
using namespace std;

int main()
{
	vector<int> v; // 벡터는 크기 지정을 안 해줘도 된다!

	int val, sum = 0;
	for (int i = 0; i < 9; i++){
		cin >> val;
		v.push_back(val);
		sum += val;
	}
	int gap = sum - 100;

	bool found = false;
	int i = 0;
	while (!found) { // not found라면 반복
		for (int j = i + 1; j < 9; j++) {
			if (v[i] + v[j] == gap) {
				v.erase(v.begin() + i); // 삭제 후 한칸씩 앞으로 당겨지므로
				v.erase(v.begin() + (j - 1)); // j-1번째 원소 삭제
				found = true;
				break;
			}
		}
		i++;
	}

	// 오름차순 정렬
	sort(v.begin(), v.end());

	for (auto& ele : v) // 범위 기반 for문
		cout << ele << " ";

	return 0;
}
```

이 문제를 파이썬으로 풀려면 어떻게 코드를 짜야 될까요? <br>

# Python 풀이

[참고한 블로그 링크](https://kyoung-jnn.tistory.com/entry/%EB%B0%B1%EC%A4%802309%EB%B2%88%ED%8C%8C%EC%9D%B4%EC%8D%ACPython-%EC%9D%BC%EA%B3%B1-%EB%82%9C%EC%9F%81%EC%9D%B4-Brute-force)

```python
list = [int(input()) for i in range(9)]
total = sum(list)

for i in range(9):
    for j in range(i + 1,9):
        if 100 == total - (list[i] + list[j]):
            a, b = list[i], list[j] 
            list.remove(a)
            list.remove(b)
            list.sort() # 오름차순 정렬

            for i in range(len(list)):
               print(list[i])
            break

    if len(list) < 9:
        break
```

파이썬의 remove 함수는 인덱스가 아니라 '값을 기준으로' 원소를 삭제합니다. 그런데 문제 조건에서 아홉 난쟁이의 키는 모두 다르다고 했기 때문에, 중복에 대한 고민 없이 '값을 기준으로' 원소를 삭제할 수 있습니다. 확실히 파이썬 코드가 C++보다 직관적이고 짧은 거 같은데, 아래 이미지에서 볼 수 있듯이 사용한 메모리와 실행 시간 측면에서는 C++이 우세하네요! 두 가지 언어로 모두 풀어보니 배워가는 게 많은 거 같습니다. 아직 파이썬 문법에는 익숙하지 않아서 거의 구글링에 의존하는데, 이 스터디를 통해 파이썬도 잘 다룰 수 있게 되었으면 좋겠네요! <br>

![image](https://user-images.githubusercontent.com/68090939/136382676-03a07877-bd49-4d7f-8fe9-9eb6d7e33277.png)

그럼 이만 포스트를 마치겠습니다. 다음 주에 만나요?